% section 5.1.2: Pipeline Execution

\subsubsection{Pipeline Execution}


\subsubsubsection{Exceptions}

Exception throwing and handling was improved in DC3a. The interface was
simplified by removing the virtually-unused inheritance from {\tt
DataProperty}.  Instead, five features were added:

\begin{itemize}

\item A simple string message is used as the primary payload of the
exception, for compatibility with standard C++ and Python exceptions.
This also makes throwing an exception simpler for the programmer.

\item A combination of macros and classes was used to automatically
include the file, line, and function where the exception was thrown.
This feature improves the debuggability of the code.

\item Other macros allow arbitrary additional parameters to be added to
subclasses of the generic {\tt lsst::pex::exceptions::Exception} class.

\item Further macros were defined that allow additional traceback
information, including additional messages, to be added to a caught and
rethrown exception.

\item LSST C++ exceptions are transformed via SWIG code into instances
of the {\tt LsstCppException} class in Python, which inherits from the
standard Python {\tt Exception} class.  The underlying SWIG-wrapped C++
exception is available as an argument of the {\tt LsstCppException}, and
the C++ exception's message is automatically included as part of the
Python exception's message.  Previously, LSST C++ exceptions were
transformed into Python exception classes that did not inherit from the
standard Python {\tt Exception} class.

\end{itemize}

The result was an exception design that was simpler to throw and that
targeted the location of the exception much more precisely.  Programmers
are still not using the more advanced features of the exception facility
such as re-throwing or additional parameters; if they are found to be
unneeded, the class can be further simplified in the future by removing
them.


\subsubsubsection{Provenance}

The Orca orchestration layer (see Section
\ref{sec:PipelineOrchestration}) in DC3a generates enhanced provenance
information.  In particular, the software environment and the contents
of the policy files used to run the production are written both to log
files and to the database.  Recording the software environment allows
the exact software configuration used for the run to be reproduced
later, while recording the policy files captures both platform
configuration information such as the compute nodes and database used as
well as all configurable science algorithm settings.

This provenance information, in combination with an event sent to the
production, is sufficient to enable accurate reconstruction of a given
data product resulting from that event, although a demonstration of
automated reconstruction was deferred.  When combined with the full
sequence of events sent to the production, the provenance allows exact
duplication of a given run.  The recorded provenance proved highly
useful while debugging algorithmic issues since it simplified the
construction of small reproducible test cases demonstrating problems.

The software environment is characterized by the versions of packages
maintained by {\tt eups} that are ``setup'' at the time of production
execution.  In addition, the actual directories declared as the
installation locations of the packages are also persisted, allowing
locally-setup packages and packages installed under {\tt LSST\_DEVEL} to
be identified.

The recorded policy file information includes the contents on a per-key
basis as well as an MD5 hash of the file contents and the file's
last-modified-time.  These latter two items are intended for eventual
use to remove duplicate entries when policy files are reused across
multiple runs.

The provenance written to the database goes into two sets of tables: one
set in the per-run database and one in a global database ({\tt
DC3a\_DB}) that spans all DC3a runs.  The global database permits
queries to find runs that used a given configuration.  For example, this
query finds all runs that had the {\tt pixelScaleRangeFactor} set to a
number other than 1.1:

\begin{verbatim}
SELECT prv_Run.runId, prv_PolicyKey.keyName, prv_cnf_PolicyKey.value
FROM prv_Run, prv_PolicyKey, prv_cnf_PolicyKey
WHERE prv_PolicyKey.policyKeyId = prv_cnf_PolicyKey.policyKeyId
  AND keyName = 'pixelScaleRangeFactor'
  AND value != '1.1'
  AND FLOOR(prv_PolicyKey.policyFileId / 65536) = prv_Run.offset;
\end{verbatim}

Similarly, this query finds all runs that used version 3.0.9 of the {\it
meas\_algorithms} package:

\begin{verbatim}
SELECT runId
FROM prv_SoftwarePackage NATURAL JOIN prv_cnf_SoftwarePackage
     JOIN prv_Run ON (FLOOR(prv_SoftwarePackage.packageId / 65536) = offset)
WHERE packageName = 'meas_algorithms' AND version = '3.0.9';
\end{verbatim}

