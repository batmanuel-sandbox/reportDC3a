% Section 6.6: Image Subtraction

\subsection{Image Subtraction}

The {\tt ip\_diffim} package implements the image subtraction
functionality in the {\tt IPSD}.  It was initially developed during
DC2, and is thus one of the more mature application packages in the
framework.  Much of the work during DC3a has gone into modifying the
code to use the new Applications Framework ({\tt afw})
pixel--processing interfaces, switching to a new third--party package
for the matrix math operations, a significant number of scripts to
unittest the Kernel creation, moving much of the pixel--processing
functionality from {\tt ip\_diffim} subroutines to apply() methods of
a class, implementation of more of the code in {\tt Python}, and
finally more a robust spatial modeling infrastructure.

\subsubsection{Implementation in Framework}

Two major {\tt afw} improvements facilitated the implementation of
{\tt ip\_diffim} for DC3a, both coming about due to the removal of
{\tt Vision Workbench} from the software stack.  The first was the
replacement of the {\tt VW} pixel access operations, while the second
was the adoption of the {\tt Eigen} package for linear algebra
operations.  

The {\tt afw} release version 3.1 included the first stable release of
the new pixel accessor and iterator functionality.  The entirety of
the {\tt ip\_diffim} C++ code base had to be updated to use this new
API.

The {\tt Eigen} matrix math library was adopted due to its speed and
templated design.  Compared to the {\tt VW} matrix math operations,
its considerably faster and cleaner to implement.  Using inversion of
a {\tt 500 x 500} matrix as a benchmark, VW could solve this problem
in 0.26 (using {\tt vw::math::least\_squares}) to 1.82 seconds (using
{\tt vw::math::pseudoinverse}).  In comparison, {\tt Eigen} has a
variety of methods to invert a matrix.  The fastest of these, Cholesky
decomposition (both with and without square root), takes 0.03 seconds
while LU decomposition takes 0.27 seconds.  This factor of 10 speedup
allows us to more robustly attempt to solve the matrix inverse, since
multiple attempts may be made using different options (e.g. attempt
Cholesky decomposition without square root; upon failure attempt
attempt Cholesky decomposition with square root, etc).


\subsubsection{Speed Ups}

Aside from the aforementioned linear algebra speed ups, as well as
caching improvements in the {\tt afw} convolution methods, we
implemented a specialization of convolution by delta function {\tt
Kernels}.  Since we are currently using delta functions as the basis
set for construction of our kernels, this sped up convolution by a
factor of {\bf XXX}.

\subsubsection{Algorithm Improvements}

The major improvement in the {\tt ip\_diffim} package over DC2 was in
designing an infrastructure for the spatial modelling of the Kernel.
The SpatialCell class divides the image up into a grid, and attempts
to build a single Kernel model for each Cell by choosing the brightest
object to build a Kernel around.  If that model turns out to be
inadequate (i.e. the resulting difference image is noisier than
expected), another object is used in the modelling.  This process is
repeated until a good Kernel is found, or all objects are deemed to be
inadequate, in which case the Cell is considered ``empty''.  In this
way we generate an even grid of constraints of the Kernel model across
the image, which will facitlitate the creation of the spatial Kernel
model.  The spatial fitting is now itegrated closely with the
SpatialCell class, iterating over all Cells and using their respective
models as constraints on the Kernel.


Growing the Footprints by the right size.

Decrease the number of eigen Kernels.

\subsubsection{Results}

\subsubsection{Future Work}

Setting the Kernel size based on the Psf FWHM.

Further investigation of the convolution vs. deconvolution kernel
issue is warranted.  Using the {\tt SimDeep} dataset, we have
determined that the derived Kernels are far noisier than expected even
when the process is known to be a smoothing convolution.  The Kernels
are far less self--similar than expected; consequently their spatial
modelling will be difficult.

The SpatialCell functionality was initially written for fitting of the
{\tt ip\_diffim} convolution Kernel.  However, it was subsequetly
rewritten in a more advanced form for modelling of the spatially
varying Point Spread Function.  A task post--DC3a is to update the
{\tt ip\_diffim} to use this newer SpatialCell functionality.
